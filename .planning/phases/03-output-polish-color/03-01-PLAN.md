---
phase: 03-output-polish-color
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/timeutil/relative.go
  - internal/timeutil/relative_test.go
  - internal/annotate/annotate.go
  - internal/annotate/annotate_test.go
  - internal/annotate/walker.go
  - internal/output/color.go
  - internal/output/color_test.go
  - internal/output/align.go
  - internal/output/align_test.go
  - internal/output/formatter.go
  - internal/output/formatter_test.go
autonomous: true

must_haves:
  truths:
    - "FormatRelativeTime produces two-unit output for all ranges including weeks (e.g., 5d12h ago, 2w3d ago, 3mo2w ago)"
    - "formatComment respects mtime modes: relative shows age, absolute shows ISO 8601, hide omits timestamp"
    - "formatComment uses new subresource format: 'manager /sub (age)' not 'manager (/sub) (age)'"
    - "AlignComments aligns per-block inline comments to the longest YAML line + 2-space gap"
    - "ColorManager assigns insertion-order colors from 8 bright ANSI palette"
    - "ResolveColor handles auto/always/never with NO_COLOR env var support"
  artifacts:
    - path: "internal/timeutil/relative.go"
      provides: "Two-unit relative time formatting with weeks"
      contains: "FormatRelativeTime"
    - path: "internal/output/color.go"
      provides: "Color manager with ANSI bright palette"
      exports: ["ColorManager", "ResolveColor", "BrightPalette"]
    - path: "internal/output/align.go"
      provides: "Per-block comment alignment"
      exports: ["AlignComments"]
    - path: "internal/output/formatter.go"
      provides: "Pipeline orchestrator (align then colorize)"
      exports: ["FormatOutput"]
    - path: "internal/annotate/annotate.go"
      provides: "Updated formatComment with mtime modes"
      contains: "MtimeMode"
  key_links:
    - from: "internal/output/formatter.go"
      to: "internal/output/align.go"
      via: "AlignComments call"
      pattern: "AlignComments"
    - from: "internal/output/formatter.go"
      to: "internal/output/color.go"
      via: "Colorize call"
      pattern: "Colorize|ColorManager"
    - from: "internal/output/color.go"
      to: "internal/output/align.go"
      via: "extractManagerName parses comment format from formatComment"
      pattern: "extractManagerName"
---

<objective>
Build the internal libraries for Phase 3 output polish: enhanced two-unit relative time with weeks, updated comment format with --mtime mode support, and a new internal/output/ package with color manager, comment alignment, and formatter pipeline.

Purpose: These libraries are the building blocks that Plan 02 will wire into the CLI. Separating library code from CLI integration keeps each plan focused and testable.
Output: Updated timeutil and annotate packages, new internal/output/ package with full unit test coverage.
</objective>

<execution_context>
@/Users/abalkan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abalkan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-output-polish-color/03-CONTEXT.md
@.planning/phases/03-output-polish-color/03-RESEARCH.md
@internal/timeutil/relative.go
@internal/timeutil/relative_test.go
@internal/annotate/annotate.go
@internal/annotate/annotate_test.go
@internal/annotate/walker.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Two-unit time formatting and updated comment format</name>
  <files>
    internal/timeutil/relative.go
    internal/timeutil/relative_test.go
    internal/annotate/annotate.go
    internal/annotate/annotate_test.go
    internal/annotate/walker.go
  </files>
  <action>
**Rewrite FormatRelativeTime** in `internal/timeutil/relative.go` for full two-unit granularity with weeks:
- Extract units in order: years (365d), months (30d), weeks (7d), days, hours, minutes, seconds
- Output the two largest non-zero units concatenated: `3d12h ago`, `2w3d ago`, `3mo2w ago`, `1y2mo ago`
- If only one unit is non-zero: `5d ago`, `3h ago`
- Edge cases: 0 seconds = `0s ago`, future timestamps = `just now`
- Rollover thresholds: 60s->m, 60m->h, 24h->d, 7d->w, ~4.3w->mo (30d), 12mo->y (365d)

**Update existing tests** in `internal/timeutil/relative_test.go`:
- Update the `5d ago` test to expect `5d ago` (still correct, no hours remainder)
- Add tests: `5d12h`, `2w3d`, `1w ago` (exactly 7 days), `3mo2w`, `1y2mo`, `0s ago`
- Update `3mo ago` test: 90 days = 12w6d... wait, 90d / 30 = 3mo, 0 remainder = `3mo ago` (still correct)
- Update `1y ago` test: 400d = 1y, remainder 35d = 1mo, so expect `1y1mo ago`

**Add MtimeMode type** to `internal/annotate/annotate.go`:
```go
type MtimeMode string
const (
    MtimeRelative MtimeMode = "relative"
    MtimeAbsolute MtimeMode = "absolute"
    MtimeHide     MtimeMode = "hide"
)
```

**Update Options struct** to include `Mtime MtimeMode` field (default empty string treated as "relative" for backward compat).

**Rewrite formatComment** to accept mtime mode (read from Options, or pass as parameter):
- New format: `manager /subresource (age)` -- note: space + slash, no parentheses around subresource
- relative: `manager /sub (2h15m ago)` or `manager (2h15m ago)` (no sub)
- absolute: `manager /sub (2026-02-07T12:00:00Z)` or `manager (2026-02-07T12:00:00Z)`
- hide: `manager /sub` or just `manager`
- The function signature should be `formatComment(info AnnotationInfo, now time.Time, mtime MtimeMode) string`

**Update Annotate function** to pass mtime mode from Options to formatComment.

**Update AnnotationInfo** in `internal/annotate/walker.go` -- no structural change needed, but verify the existing structure supports the new format.

**Update annotate tests** in `internal/annotate/annotate_test.go`:
- Update existing formatComment tests for new subresource format (space + slash, no parens)
- Add formatComment tests for absolute and hide modes
- Update Annotate integration tests for the new comment format (the existing tests use inline/above modes which still work, just the comment text changes)
- Ensure Options.Mtime defaults to relative behavior when empty string

**Important:** Do NOT update golden files in this task -- that happens in Plan 02. Only update unit tests that directly test formatComment and Annotate functions.
  </action>
  <verify>
Run `go test ./internal/timeutil/... ./internal/annotate/...` -- all tests pass with the updated expectations.
  </verify>
  <done>
FormatRelativeTime produces two-unit output for all ranges including weeks. formatComment supports relative/absolute/hide modes with new subresource format. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Output package -- color manager, comment alignment, formatter</name>
  <files>
    internal/output/color.go
    internal/output/color_test.go
    internal/output/align.go
    internal/output/align_test.go
    internal/output/formatter.go
    internal/output/formatter_test.go
  </files>
  <action>
Create new `internal/output/` package with three files:

**color.go -- Color manager and ANSI support:**
- `BrightPalette` variable: 8 bright ANSI colors as escape sequences. Use SGR bright codes:
  - `\x1b[96m` Bright Cyan, `\x1b[92m` Bright Green, `\x1b[93m` Bright Yellow, `\x1b[95m` Bright Magenta, `\x1b[91m` Bright Red, `\x1b[94m` Bright Blue, `\x1b[36m` Cyan (standard), `\x1b[33m` Yellow (standard)
- `Reset` constant: `\x1b[0m`
- `ColorManager` struct: palette []string, assign map[string]int, order []string
- `NewColorManager()` constructor with BrightPalette
- `(cm *ColorManager) ColorFor(managerName string) string` -- returns ANSI code for manager, assigns insertion-order on first encounter
- `(cm *ColorManager) Wrap(text, managerName string) string` -- wraps text in manager's color + reset
- `extractManagerName(comment string) string` -- extracts manager name from comment text for color lookup. Manager name is everything from start of comment (after optional `# `) up to first ` /` (subresource) or ` (` (timestamp) or end of string.
- `ResolveColor(flag string, fd uintptr) bool` -- resolves color enabled state:
  - "always" -> true (overrides everything including NO_COLOR)
  - "never" -> false
  - "auto" -> if NO_COLOR env set and non-empty -> false, else check term.IsTerminal(int(fd)) -> true/false
  - NOTE: Do not import golang.org/x/term yet -- accept an `fd uintptr` parameter and use a `var isTerminal = func(fd int) bool { ... }` package-level function variable that defaults to `term.IsTerminal`. This enables testing without a real TTY. Actually simpler: accept a `tty bool` parameter that the caller pre-computes. Let main.go call term.IsTerminal and pass the result. This avoids the x/term import in the output package.
  - Revised: `ResolveColor(flag string, isTTY bool) bool`

**align.go -- Per-block comment alignment:**
- `const MinGap = 2`
- `splitInlineComment(line string) (content string, comment string, hasComment bool)` -- splits a line at the last ` # ` occurrence. Returns false if no inline comment found (line is all whitespace before `#`, or no `#` at all). The "content" is everything before the ` # `, the "comment" is everything from `# ` onward (including the `# ` prefix).
- `AlignComments(text string) string` -- per-block alignment algorithm:
  1. Split text into lines
  2. Iterate lines, grouping consecutive lines that have inline comments (via splitInlineComment)
  3. A line without an inline comment breaks the group
  4. For each block: alignment column = max content length in block + MinGap
  5. For each line in block: if content length > alignment_col - MinGap, use content + "  " + comment (minimum gap). Otherwise, pad content to alignment column then append comment.
  6. Lines without comments pass through unchanged
  7. Join and return
- Above-mode HeadComment lines (whitespace + `# ...`) are NOT inline comments -- splitInlineComment returns false for these. They pass through unchanged. Per user decision: above mode has no column alignment.

**formatter.go -- Pipeline orchestrator:**
- `FormatOutput(text string, colorEnabled bool, colorMgr *ColorManager) string` -- orchestrates the pipeline:
  1. AlignComments(text) -- always runs (alignment always on per user decision)
  2. If colorEnabled: Colorize(aligned, colorMgr)
  3. Return result
- `Colorize(text string, cm *ColorManager) string` -- applies color to comments in text:
  1. Split into lines
  2. For each line: detect inline comment (content + ` # ...`) or above comment (whitespace + `# ...`)
  3. For inline: extract manager name from comment, wrap comment portion with cm.Wrap
  4. For above: extract manager name from comment text, wrap the `# ...` portion with cm.Wrap
  5. Non-comment lines pass through unchanged
  6. The `#` is part of the colored text per user decision

**Unit tests:**
- `color_test.go`: Test insertion-order assignment (first manager gets index 0, second gets index 1, same manager returns same color). Test Wrap produces ANSI prefix + text + reset. Test extractManagerName with: `manager (5d ago)`, `manager /status (5d ago)`, `manager /status`, `manager`, `# manager (5d ago)`. Test ResolveColor: always=true, never=false, auto+tty=true, auto+notty=false, auto+NO_COLOR=false (use t.Setenv).
- `align_test.go`: Test splitInlineComment with inline comment line, no comment line, above-mode comment line (should return false). Test AlignComments with: a block of 3 annotated lines (verify alignment), a block broken by unannotated line (two separate groups), a long line exceeding alignment column (gets min gap), mixed annotated and bare lines.
- `formatter_test.go`: Test FormatOutput with color disabled (just alignment). Test FormatOutput with color enabled (comments wrapped in ANSI). Test Colorize with inline and above-mode comments. Test that YAML content is NOT colorized (only comments).
  </action>
  <verify>
Run `go test ./internal/output/...` -- all tests pass. Run `go vet ./internal/output/...` -- no issues.
  </verify>
  <done>
internal/output/ package exists with ColorManager (insertion-order 8-color palette), AlignComments (per-block alignment with 2-space min gap), FormatOutput (align-then-colorize pipeline), and Colorize (ANSI wrapping for inline and above comments). All unit tests pass.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/timeutil/...` passes with two-unit time formatting
- `go test ./internal/annotate/...` passes with updated comment format and mtime modes
- `go test ./internal/output/...` passes with color, alignment, and formatter tests
- `go vet ./...` passes with no issues
- `go build ./...` compiles successfully (even though CLI not yet wired)
</verification>

<success_criteria>
- FormatRelativeTime outputs two-unit values for all ranges (s, m+s, h+m, d+h, w+d, mo+w, y+mo)
- formatComment produces correct output for all three mtime modes with new subresource format
- AlignComments aligns per-block inline comments to uniform column
- ColorManager assigns colors in insertion order from 8-color bright palette
- ResolveColor handles auto/always/never with NO_COLOR support
- FormatOutput runs align-then-colorize pipeline
- All tests across all three packages pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-output-polish-color/03-01-SUMMARY.md`
</output>
