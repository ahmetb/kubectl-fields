---
phase: 01-foundation-input-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/managed/extract.go
  - internal/managed/extract_test.go
  - internal/managed/strip.go
  - internal/managed/strip_test.go
  - internal/managed/fieldsv1.go
  - internal/managed/fieldsv1_test.go
  - internal/timeutil/relative.go
  - internal/timeutil/relative_test.go
  - cmd/kubectl-fields/main.go
  - internal/parser/parser.go
autonomous: true

must_haves:
  truths:
    - "Piping kubectl YAML with managedFields through the tool produces output with managedFields stripped and all other content preserved"
    - "Piping YAML without managedFields produces unchanged output plus a stderr warning mentioning --show-managed-fields"
    - "ManagedFieldsEntry structs are correctly extracted from YAML nodes with manager, operation, subresource, time, apiVersion, and FieldsV1 node"
    - "FieldsV1 key prefixes (f:, k:, v:, .) are correctly parsed from key strings"
    - "Relative timestamps format correctly: seconds, minutes, hours, days, months, years"
  artifacts:
    - path: "internal/managed/extract.go"
      provides: "ExtractManagedFields function returning []ManagedFieldsEntry from a YAML MappingNode"
      exports: ["ManagedFieldsEntry", "ExtractManagedFields"]
    - path: "internal/managed/strip.go"
      provides: "StripManagedFields function removing managedFields key from metadata"
      exports: ["StripManagedFields"]
    - path: "internal/managed/fieldsv1.go"
      provides: "ParseFieldsV1Key and ParseAssociativeKey functions for FieldsV1 prefix parsing"
      exports: ["ParseFieldsV1Key", "ParseAssociativeKey"]
    - path: "internal/timeutil/relative.go"
      provides: "FormatRelativeTime function for human-readable relative timestamps"
      exports: ["FormatRelativeTime"]
    - path: "cmd/kubectl-fields/main.go"
      provides: "Updated CLI that extracts, strips managedFields, warns on missing managedFields"
      min_lines: 50
  key_links:
    - from: "cmd/kubectl-fields/main.go"
      to: "internal/managed/extract.go"
      via: "calls ExtractManagedFields to get entries (stored for Phase 2 annotation)"
      pattern: "managed\\.ExtractManagedFields"
    - from: "cmd/kubectl-fields/main.go"
      to: "internal/managed/strip.go"
      via: "calls StripManagedFields to remove managedFields from each resource"
      pattern: "managed\\.StripManagedFields"
    - from: "internal/managed/fieldsv1.go"
      to: "encoding/json"
      via: "json.Unmarshal for k: prefix JSON content"
      pattern: "json\\.Unmarshal"
---

<objective>
Build the managed fields extraction, FieldsV1 prefix parsing, relative time formatting, and managedFields stripping -- then wire everything into the CLI so the tool produces clean YAML output.

Purpose: This completes Phase 1's goal: users can pipe `kubectl get deploy -o yaml --show-managed-fields | kubectl-fields` and get clean YAML back with managedFields stripped. The extracted ManagedFieldsEntry data structures are the foundation Phase 2's annotation engine builds on. The FieldsV1 parser and time formatter are also needed in Phase 2.

Output: A working end-to-end pipeline. The existing test fixture `testdata/1_deployment.yaml` piped through the tool should produce output identical to the input minus the managedFields block. YAML without managedFields should pass through with a stderr warning.
</objective>

<execution_context>
@/Users/abalkan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abalkan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-input-pipeline/01-RESEARCH.md
@.planning/phases/01-foundation-input-pipeline/01-01-SUMMARY.md
@testdata/1_deployment.yaml
@testdata/0_no_managedFields.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: ManagedFields extraction, FieldsV1 prefix parser, and relative time formatter</name>
  <files>
    internal/managed/extract.go
    internal/managed/extract_test.go
    internal/managed/fieldsv1.go
    internal/managed/fieldsv1_test.go
    internal/timeutil/relative.go
    internal/timeutil/relative_test.go
  </files>
  <action>
Create `internal/managed/extract.go`:

Define the `ManagedFieldsEntry` struct:
```go
type ManagedFieldsEntry struct {
    Manager     string
    Operation   string
    Subresource string
    Time        time.Time
    APIVersion  string
    FieldsV1    *yaml.Node // Raw YAML MappingNode of the ownership tree
}
```

Implement `ExtractManagedFields(root *yaml.Node) ([]ManagedFieldsEntry, error)`:
- root must be a MappingNode (the resource root, NOT the DocumentNode)
- Find "metadata" key in root -> get its MappingNode value
- Find "managedFields" key in metadata -> get its SequenceNode value
- If metadata not found or managedFields not found, return nil, nil (not an error)
- If managedFields is not a SequenceNode, return error
- For each item in the SequenceNode.Content, call parseManagedFieldEntry(item)
- Return the slice of entries

Implement unexported `parseManagedFieldEntry(node *yaml.Node) (ManagedFieldsEntry, error)`:
- node is a MappingNode with keys: manager, operation, time, apiVersion, fieldsType, fieldsV1, subresource
- Extract each using getMapValue/getMapValueNode helper (reuse from parser package or duplicate locally -- prefer duplicating to avoid circular imports)
- Parse time with `time.Parse(time.RFC3339, v)`
- Store the fieldsV1 MappingNode directly in entry.FieldsV1
- Ignore fieldsType (always "FieldsV1" in practice)

Include unexported helpers: `getMapValue(mapping, key)` and `getMapValueNode(mapping, key)` -- same logic as parser package but in managed package to avoid circular imports. These are small (5 lines each), duplication is fine.

Create `internal/managed/extract_test.go`:

**TestExtractManagedFields_Deployment** -- Parse `testdata/1_deployment.yaml`, get root MappingNode from doc.Content[0], call ExtractManagedFields. Assert:
- 4 entries returned (kubectl-client-side-apply, envpatcher, kube-controller-manager, finalizerpatcher)
- Entry 0: Manager="kubectl-client-side-apply", Operation="Update", Subresource=""
- Entry 2: Manager="kube-controller-manager", Operation="Update", Subresource="status"
- Entry 3: Manager="finalizerpatcher"
- All entries have non-zero Time
- Entry 0 FieldsV1 is not nil and is a MappingNode

**TestExtractManagedFields_NoMetadata** -- Create a minimal YAML node with no metadata key. Assert returns nil, nil.

**TestExtractManagedFields_NoManagedFields** -- Parse `testdata/0_no_managedFields.yaml`. Assert returns nil, nil.

---

Create `internal/managed/fieldsv1.go`:

Implement `ParseFieldsV1Key(key string) (prefix string, content string)`:
- If key == ".", return ".", ""
- Find first ':' with `strings.IndexByte(key, ':')`
- If no colon found, return "", key (malformed)
- Return key[:idx] as prefix, key[idx+1:] as content
- Expected prefixes: "f", "k", "v", "i"

Implement `ParseAssociativeKey(jsonStr string) (map[string]interface{}, error)`:
- Use `json.Unmarshal([]byte(jsonStr), &result)` to parse the JSON object
- Return the map and any error
- This handles both single-field keys like `{"name":"nginx"}` and multi-field keys like `{"containerPort":80,"protocol":"TCP"}`

Create `internal/managed/fieldsv1_test.go`:

**TestParseFieldsV1Key_FieldPrefix** -- Assert `ParseFieldsV1Key("f:metadata")` returns ("f", "metadata")

**TestParseFieldsV1Key_AssociativePrefix** -- Assert `ParseFieldsV1Key(`k:{"name":"nginx"}`)` returns ("k", `{"name":"nginx"}`)

**TestParseFieldsV1Key_ValuePrefix** -- Assert `ParseFieldsV1Key(`v:"example.com/foo"`)` returns ("v", `"example.com/foo"`)

**TestParseFieldsV1Key_DotMarker** -- Assert `ParseFieldsV1Key(".")` returns (".", "")

**TestParseFieldsV1Key_Malformed** -- Assert `ParseFieldsV1Key("noprefix")` returns ("", "noprefix")

**TestParseAssociativeKey_SingleField** -- Parse `{"name":"nginx"}`, assert map has "name"="nginx"

**TestParseAssociativeKey_MultiField** -- Parse `{"containerPort":80,"protocol":"TCP"}`, assert map has both keys with correct values (containerPort as float64 due to JSON number parsing, protocol as string)

**TestParseAssociativeKey_Invalid** -- Parse `not-json`, assert error returned

---

Create `internal/timeutil/relative.go`:

Implement `FormatRelativeTime(now, then time.Time) string`:
- If duration is negative (then is in the future), return "just now"
- Less than 60 seconds: `"%ds ago"` (e.g., "45s ago")
- Less than 1 hour: `"%dm ago"` or `"%dm%ds ago"` (e.g., "5m ago", "3m10s ago"). Include seconds only if > 0.
- Less than 24 hours: `"%dh ago"` or `"%dh%dm ago"` (e.g., "2h ago", "3h10m ago"). Include minutes only if > 0.
- Less than 30 days: `"%dd ago"` (e.g., "5d ago"). No sub-day granularity.
- Less than 365 days: `"%dmo ago"` (e.g., "3mo ago").
- 365+ days: `"%dy ago"` (e.g., "2y ago").

Create `internal/timeutil/relative_test.go`:

Test cases (use a fixed "now" time and compute "then" by subtracting):
- **TestFormatRelativeTime_Seconds** -- 45 seconds ago -> "45s ago"
- **TestFormatRelativeTime_Minutes** -- 5 minutes ago -> "5m ago"
- **TestFormatRelativeTime_MinutesAndSeconds** -- 3 min 10 sec ago -> "3m10s ago"
- **TestFormatRelativeTime_Hours** -- 2 hours ago -> "2h ago"
- **TestFormatRelativeTime_HoursAndMinutes** -- 3 hours 10 min ago -> "3h10m ago"
- **TestFormatRelativeTime_Days** -- 5 days ago -> "5d ago"
- **TestFormatRelativeTime_Months** -- 90 days ago -> "3mo ago"
- **TestFormatRelativeTime_Years** -- 400 days ago -> "1y ago"
- **TestFormatRelativeTime_Future** -- 10 seconds in the future -> "just now"
- **TestFormatRelativeTime_Zero** -- now == then -> "0s ago" (edge case: 0 seconds)
  </action>
  <verify>
Run `go test ./internal/managed/ -v` -- all tests pass.
Run `go test ./internal/timeutil/ -v` -- all tests pass.
  </verify>
  <done>
ManagedFieldsEntry extraction works with real kubectl YAML fixtures. FieldsV1 prefix parser handles all prefix types (f:, k:, v:, .) and JSON associative keys. Relative time formatter produces correct human-readable strings across all time ranges.
  </done>
</task>

<task type="auto">
  <name>Task 2: ManagedFields stripping, CLI wiring, and end-to-end validation</name>
  <files>
    internal/managed/strip.go
    internal/managed/strip_test.go
    cmd/kubectl-fields/main.go
    internal/parser/parser.go
  </files>
  <action>
Create `internal/managed/strip.go`:

Implement `StripManagedFields(root *yaml.Node) bool`:
- root must be a MappingNode (the resource root)
- Find "metadata" key -> get its MappingNode value
- If metadata not found or not a MappingNode, return false
- Call removeMapKey(metadata, "managedFields") -- splices out the key-value pair
- Return true if removed, false if not found

Unexported helper `removeMapKey(mapping *yaml.Node, key string) bool`:
- Iterate Content by 2 (key-value pairs)
- When Content[i].Value == key, splice out Content[i] and Content[i+1] using append
- Return true if spliced, false if key not found
- IMPORTANT: use `mapping.Content = append(mapping.Content[:i], mapping.Content[i+2:]...)` to splice

Create `internal/managed/strip_test.go`:

**TestStripManagedFields_Deployment** -- Parse `testdata/1_deployment.yaml`, get root node, call StripManagedFields. Assert:
- Returns true (managedFields was found and removed)
- Re-encode to string, verify "managedFields" does NOT appear in output
- Verify "metadata" key still exists with remaining fields (name, namespace, labels, annotations, etc.)
- Verify "spec" and "status" sections are unchanged

**TestStripManagedFields_NoManagedFields** -- Parse `testdata/0_no_managedFields.yaml`. Assert returns false (nothing to strip). Re-encode and verify output equals input.

**TestStripManagedFields_RoundTripPreservation** -- Parse `testdata/1_deployment.yaml`, strip managedFields, encode. Verify:
- Output is valid YAML (re-parseable)
- All fields EXCEPT managedFields are preserved with correct values
- Indentation and key ordering match the input for non-managedFields sections
- Specifically check: annotations with literal block scalar (`|`), quoted timestamp values, compact sequence indentation for containers/ports

---

Update `cmd/kubectl-fields/main.go` to wire the full pipeline:

The RunE function should:
1. Call `parser.ParseDocuments(os.Stdin)` to get document nodes
2. For each document, detect and handle List kind:
   - Call `parser.UnwrapListKind(doc)` to get individual resources
3. Track whether ANY managedFields were found across all resources (boolean flag)
4. For each resource node:
   - Get the root MappingNode from doc.Content[0]
   - Call `managed.ExtractManagedFields(root)` -- store the result for now (Phase 2 will use it for annotation). If entries are returned, set the "found" flag.
   - Call `managed.StripManagedFields(root)` -- removes managedFields from the YAML tree
5. After processing all resources, if NO managedFields were found in ANY document:
   - Print to stderr: `fmt.Fprintln(os.Stderr, "Warning: no managedFields found. Did you use --show-managed-fields?")`
6. Call `parser.EncodeDocuments(os.Stdout, allDocs)` where allDocs is the flattened list of all processed documents (including unwrapped List items)
7. Return any errors encountered

Update imports in main.go to include the managed package.

Also add a `ProcessDocuments` function to `internal/parser/parser.go` (or keep the logic in main.go -- main.go is simpler for now since it's a thin orchestrator):
- This is the "process each doc through unwrap + extract + strip" loop
- For now, keep it in main.go. If it grows beyond ~30 lines, refactor to parser package in a later plan.
  </action>
  <verify>
Run `go test ./... -v` -- ALL tests pass (parser, managed, timeutil).
Run `go vet ./...` -- no warnings.

End-to-end validation:
1. `cat testdata/1_deployment.yaml | go run ./cmd/kubectl-fields` -- verify output has NO managedFields section, all other fields preserved
2. `cat testdata/0_no_managedFields.yaml | go run ./cmd/kubectl-fields 2>stderr.txt` -- verify output is unchanged AND stderr.txt contains the warning about --show-managed-fields
3. `cat testdata/roundtrip/multidoc.yaml | go run ./cmd/kubectl-fields` -- verify multi-doc still works with the stripping pipeline
4. `make build && make test` -- Makefile targets work

Cleanup: `rm -f stderr.txt`
  </verify>
  <done>
The complete Phase 1 pipeline works: stdin YAML is parsed, managedFields are extracted (for later use) and stripped, and clean YAML is emitted to stdout. YAML without managedFields passes through with a stderr warning. All tests pass. The tool is ready for Phase 2's annotation engine to use the extracted ManagedFieldsEntry data.
  </done>
</task>

</tasks>

<verification>
1. `go build ./cmd/kubectl-fields` compiles without errors
2. `go test ./... -v` passes all tests across all packages
3. `go vet ./...` reports no issues
4. `cat testdata/1_deployment.yaml | go run ./cmd/kubectl-fields` produces output with managedFields removed and everything else intact
5. `cat testdata/0_no_managedFields.yaml | go run ./cmd/kubectl-fields 2>&1 >/dev/null` shows the missing managedFields warning on stderr
6. `cat testdata/1_deployment.yaml | go run ./cmd/kubectl-fields | grep -c managedFields` returns 0 (no managedFields in output)
7. Phase 1 success criteria #1-4 from ROADMAP.md are satisfied
</verification>

<success_criteria>
- ManagedFields extraction correctly parses all 4 entries from the deployment fixture (kubectl-client-side-apply, envpatcher, kube-controller-manager with subresource, finalizerpatcher)
- FieldsV1 prefix parser handles f:, k: (with JSON), v:, and . correctly
- Relative time formatter produces correct strings for all time ranges (seconds through years)
- ManagedFields stripping removes the managedFields block while preserving all other YAML content
- CLI produces clean output with managedFields stripped
- Missing managedFields triggers a helpful stderr warning
- All tests pass, go vet clean
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-input-pipeline/01-02-SUMMARY.md`
</output>
