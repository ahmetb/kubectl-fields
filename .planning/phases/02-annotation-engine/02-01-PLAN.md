---
phase: 02-annotation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/annotate/annotate.go
  - internal/annotate/walker.go
  - internal/annotate/annotate_test.go
  - internal/annotate/walker_test.go
autonomous: true

must_haves:
  truths:
    - "Scalar fields owned by a manager get inline comments showing manager name and relative timestamp"
    - "Container fields (mapping/sequence-valued) owned via '.' get inline comments on the key node"
    - "Above mode places HeadComment on key node instead of LineComment"
    - "Subresource is included in annotation when present (e.g., (/status))"
    - "Fields not in any managedFields entry have no comment"
    - "Empty-mapping FieldsV1 values are treated as leaves (annotate) not non-leaves (recurse)"
  artifacts:
    - path: "internal/annotate/annotate.go"
      provides: "Annotate() function with two-pass collect-then-inject, Options struct, formatComment"
      exports: ["Annotate", "Options", "AnnotationInfo"]
    - path: "internal/annotate/walker.go"
      provides: "walkFieldsV1 parallel descent, findMappingField, isLeaf, AnnotationTarget"
      exports: ["AnnotationTarget"]
    - path: "internal/annotate/annotate_test.go"
      provides: "Unit tests for formatComment and Annotate with inline/above modes"
    - path: "internal/annotate/walker_test.go"
      provides: "Unit tests for findMappingField, isLeaf, walkFieldsV1 with f: prefix"
  key_links:
    - from: "internal/annotate/walker.go"
      to: "internal/managed/fieldsv1.go"
      via: "managed.ParseFieldsV1Key(key)"
      pattern: "managed\\.ParseFieldsV1Key"
    - from: "internal/annotate/annotate.go"
      to: "internal/timeutil/relative.go"
      via: "timeutil.FormatRelativeTime(now, info.Time)"
      pattern: "timeutil\\.FormatRelativeTime"
    - from: "internal/annotate/annotate.go"
      to: "internal/managed/extract.go"
      via: "managed.ManagedFieldsEntry type in function signature"
      pattern: "managed\\.ManagedFieldsEntry"
---

<objective>
Build the parallel descent walker and comment injection engine for f: field matching with both inline and above comment modes.

Purpose: This is the core annotation algorithm -- walking FieldsV1 ownership trees in parallel with the YAML document tree and injecting ownership comments on matching nodes. This plan handles scalar fields (f: prefix), container fields (. dot marker), and leaf detection. List item matching (k:, v:) is deferred to plan 02-02.

Output: `internal/annotate/` package with Annotate() function, walker, and comprehensive unit tests for f: field matching and comment placement.
</objective>

<execution_context>
@/Users/abalkan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abalkan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-annotation-engine/02-RESEARCH.md
@internal/managed/extract.go
@internal/managed/fieldsv1.go
@internal/timeutil/relative.go
@internal/parser/parser.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Walker and annotation target types</name>
  <files>internal/annotate/walker.go, internal/annotate/walker_test.go</files>
  <action>
Create `internal/annotate/walker.go` with:

1. **AnnotationTarget struct** storing both key and value yaml.Node pointers plus AnnotationInfo:
```go
type AnnotationTarget struct {
    KeyNode   *yaml.Node  // key in mapping (for above mode, or inline on containers)
    ValueNode *yaml.Node  // value in mapping (for inline on scalars); nil for sequence items
    Info      AnnotationInfo
}

type AnnotationInfo struct {
    Manager     string
    Subresource string
    Time        time.Time
}
```

2. **walkFieldsV1(yamlNode, fieldsNode, entry, targets)** - The parallel descent function:
   - `fieldsNode` is the FieldsV1 `*yaml.Node` (MappingNode)
   - Iterate key-value pairs in fieldsNode.Content
   - Call `managed.ParseFieldsV1Key(key)` to get prefix + content
   - Handle prefixes:
     - `.` (dot): Store AnnotationTarget with yamlNode as both KeyNode and ValueNode (the injection pass will determine placement)
     - `f:` (field): Find the matching key-value pair in yamlNode using `findMappingField(yamlNode, content)`. If leaf (`isLeaf(val)`), store target with keyNode and valueNode. If non-leaf, recurse into valueNode.
     - `k:` and `v:`: Skip for now (stub with `continue` and a `// TODO(02-02)` comment) -- handled in plan 02-02
   - The `.` entry annotates the CURRENT yamlNode (the parent), not a child. For `f:annotations: { .: {} }`, the `.` means annotations itself is managed. The target should set KeyNode to the key of annotations in its parent mapping, and ValueNode to the annotations mapping node. This requires passing the parent context. **Simpler approach per research:** when walkFieldsV1 encounters `.`, it annotates the yamlNode passed to it. When the caller (the `f:` handler) recurses, it passes the value node. So `.` at that level annotates the value node. The injection pass then selects the correct node based on node kind (scalar value -> LineComment on value; mapping/seq value -> LineComment on key).

   **Corrected approach for dot handling:** The `f:` handler, when recursing into a non-leaf, passes `targetVal` (the value node) as yamlNode. So when the recursed level encounters `.`, `yamlNode` IS the value node (e.g., the annotations MappingNode). The AnnotationTarget for `.` should store: KeyNode = the key node from the PARENT level, ValueNode = yamlNode (the current node). This means the `f:` handler must pass the key node down. Use a `parentKeyNode` parameter:

```go
func walkFieldsV1(yamlNode *yaml.Node, parentKeyNode *yaml.Node, fieldsNode *yaml.Node, entry managed.ManagedFieldsEntry, targets map[*yaml.Node]AnnotationTarget)
```

   When `.` is encountered: store target with KeyNode=parentKeyNode (may be nil at root), ValueNode=yamlNode.
   When `f:fieldName` is leaf: store target with KeyNode=targetKey, ValueNode=targetVal.
   When `f:fieldName` is non-leaf: recurse with walkFieldsV1(targetVal, targetKey, val, entry, targets).

   The targets map is keyed by the ValueNode pointer (to handle last-writer-wins for the same node).

3. **findMappingField(mapping, fieldName)** - returns (keyNode, valueNode *yaml.Node):
   - If mapping.Kind != MappingNode, return nil, nil
   - Iterate Content pairs, match by key Value
   - Return the key and value nodes

4. **isLeaf(node)** - returns bool:
   - `node.Kind == yaml.MappingNode && len(node.Content) == 0`
   - An empty mapping in FieldsV1 means "this is a leaf field"

5. **annotationFrom(entry)** helper - creates AnnotationInfo from ManagedFieldsEntry.

Create `internal/annotate/walker_test.go` with tests:
- `TestFindMappingField` - finds existing key, returns nil for missing key, handles non-mapping
- `TestIsLeaf` - empty mapping is leaf, non-empty mapping is not leaf, scalar is not leaf
- `TestWalkFieldsV1_SimpleScalarFields` - Build a simple YAML mapping `{replicas: 3, image: nginx}` and a FieldsV1 tree `{f:replicas: {}, f:image: {}}`. Verify targets map has entries for both value nodes with correct AnnotationInfo.
- `TestWalkFieldsV1_NestedFields` - YAML with `metadata: {labels: {app: nginx}}` and FieldsV1 `{f:metadata: {f:labels: {.: {}, f:app: {}}}}`. Verify: labels key gets a dot target, app value gets a field target.
- `TestWalkFieldsV1_LeafContainerField` - FieldsV1 `{f:selector: {}}` (leaf, empty mapping). Verify selector gets annotated as a leaf (target stored), not recursed into.
- `TestWalkFieldsV1_UnmanagedFieldsIgnored` - YAML has fields not in FieldsV1. Verify targets map does NOT include them (REQ-013).

Use `github.com/stretchr/testify/assert` for assertions. Build yaml.Node trees programmatically for unit tests (create MappingNode with Content slices).
  </action>
  <verify>
Run `cd /Users/abalkan/oss/kubectl-fields20 && go test ./internal/annotate/ -run TestFind && go test ./internal/annotate/ -run TestIsLeaf && go test ./internal/annotate/ -run TestWalk` -- all tests pass. Run `go vet ./internal/annotate/` -- no issues.
  </verify>
  <done>
Walker correctly traverses FieldsV1 tree, matches f: fields to YAML nodes, handles dot marker, distinguishes leaf vs non-leaf, and ignores unmanaged fields. All walker unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Annotate function with comment injection</name>
  <files>internal/annotate/annotate.go, internal/annotate/annotate_test.go</files>
  <action>
Create `internal/annotate/annotate.go` with:

1. **Options struct:**
```go
type Options struct {
    Above bool      // true = HeadComment above field, false = LineComment inline
    Now   time.Time // current time for relative timestamps (enables deterministic tests)
}
```

2. **formatComment(info AnnotationInfo, now time.Time) string:**
   - Format: `manager (age)` or `manager (/subresource) (age)`
   - Use `timeutil.FormatRelativeTime(now, info.Time)` for the age
   - Return the string WITHOUT the `#` prefix -- go-yaml adds `# ` automatically when setting HeadComment/LineComment

3. **Annotate(root *yaml.Node, entries []managed.ManagedFieldsEntry, opts Options):**
   - Root should be the resource MappingNode (not DocumentNode). Caller unwraps DocumentNode.
   - **Pass 1 - Collect:** Create `targets := make(map[*yaml.Node]AnnotationTarget)`. For each entry with non-nil FieldsV1, call `walkFieldsV1(root, nil, entry.FieldsV1, entry, targets)`.
   - **Pass 2 - Inject:** For each target in the map:
     - **Inline mode (opts.Above == false):**
       - If ValueNode is ScalarNode: set `ValueNode.LineComment = comment`
       - If ValueNode is MappingNode or SequenceNode: set `KeyNode.LineComment = comment` (container fields like `annotations:` get comment on the key)
       - If ValueNode == KeyNode (dot on root-level, rare): set `KeyNode.LineComment = comment`
       - Special: if KeyNode is nil (sequence item from k: match, handled in 02-02): skip for now
     - **Above mode (opts.Above == true):**
       - If KeyNode is not nil: set `KeyNode.HeadComment = comment`
       - If KeyNode is nil (sequence scalar from v: match): set `ValueNode.HeadComment = comment`

   Note: go-yaml's HeadComment and LineComment fields expect the comment text WITHOUT the `# ` prefix. go-yaml prepends `# ` automatically during encoding.

Create `internal/annotate/annotate_test.go` with tests:

- `TestFormatComment_Basic` - manager "kubectl-client-side-apply", time 50m ago -> "kubectl-client-side-apply (50m ago)"
- `TestFormatComment_WithSubresource` - manager "kube-controller-manager", subresource "status" -> "kube-controller-manager (/status) (1h ago)"
- `TestFormatComment_NoSubresource` - no subresource -> no (/sub) part
- `TestAnnotate_InlineSimpleFields` - Build YAML `replicas: 3` with FieldsV1 `{f:replicas: {}}`. Parse, annotate with inline mode, encode, verify output contains `replicas: 3 # manager (age)`.
- `TestAnnotate_InlineContainerField` - Build YAML `labels:\n  app: nginx` with FieldsV1 `{f:labels: {.: {}, f:app: {}}}`. Verify `labels: # manager (age)` and `app: nginx # manager (age)`.
- `TestAnnotate_AboveMode` - Same as inline test but with Above=true. Verify `# manager (age)\nreplicas: 3` (HeadComment above key).
- `TestAnnotate_UnmanagedFieldBare` - YAML has `replicas: 3` and `image: nginx` but FieldsV1 only has `f:replicas: {}`. Verify replicas has comment, image does NOT.
- `TestAnnotate_SubresourceInComment` - Entry with Subresource="status". Verify comment contains "(/status)".
- `TestAnnotate_MultipleManagers` - Two entries owning different fields. Verify each field gets the correct manager's annotation.

For tests that verify encoded output: use `parser.EncodeDocuments` (or yaml.NewEncoder with SetIndent(2) + CompactSeqIndent()) to encode, then check the output string contains expected comment patterns. Use a fixed `Now` time for deterministic timestamps.
  </action>
  <verify>
Run `cd /Users/abalkan/oss/kubectl-fields20 && go test ./internal/annotate/ -v` -- all tests pass. Run `go vet ./internal/annotate/` -- no issues. Run `go build ./...` -- clean build.
  </verify>
  <done>
Annotate() function correctly injects inline and above comments on scalar and container fields. Comment format includes manager name, optional subresource, and relative timestamp. Multiple managers annotate their own fields independently. Unmanaged fields remain bare. All annotation tests pass.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/annotate/ -v` passes all tests
- `go vet ./internal/annotate/` reports no issues
- `go build ./...` compiles cleanly
- Walker handles: f: scalar leaf, f: non-leaf recurse, . dot marker, leaf detection (empty mapping), unmanaged field exclusion
- Annotate handles: inline mode (LineComment), above mode (HeadComment), subresource display, multiple managers
</verification>

<success_criteria>
- internal/annotate/ package exists with walker.go, annotate.go, and test files
- walkFieldsV1 correctly descends FieldsV1 tree matching f: fields to YAML nodes
- Annotate() two-pass (collect then inject) works for both inline and above modes
- Comment format: "manager (age)" or "manager (/subresource) (age)"
- Unmanaged fields get no annotation (REQ-013)
- All tests pass, go vet clean, builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-annotation-engine/02-01-SUMMARY.md`
</output>
