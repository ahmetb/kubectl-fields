---
phase: 02-annotation-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/annotate/walker.go
  - internal/annotate/annotate.go
  - internal/annotate/annotate_test.go
  - internal/annotate/walker_test.go
  - cmd/kubectl-fields/main.go
autonomous: true

must_haves:
  truths:
    - "List items matched by k: associative key (e.g., containers by name, ports by containerPort+protocol) are correctly annotated"
    - "List items matched by k: with '.' entry show the item itself as managed (inline: HeadComment on first key; above: HeadComment on mapping node)"
    - "Scalar list items matched by v: prefix (e.g., finalizer values) are correctly annotated"
    - "JSON-encoded v: content is decoded before comparison (e.g., v:\"example.com/foo\" matches example.com/foo)"
    - "CLI --above flag switches from inline to above comment placement"
    - "End-to-end: deployment YAML piped through tool produces annotated output matching expected golden files"
  artifacts:
    - path: "internal/annotate/walker.go"
      provides: "k: associative key matching, v: set value matching added to walkFieldsV1"
      contains: "findSequenceItemByKey"
    - path: "internal/annotate/annotate.go"
      provides: "k: item comment injection (HeadComment on first key for inline, HeadComment on mapping for above)"
      contains: "injectComment"
    - path: "cmd/kubectl-fields/main.go"
      provides: "Annotate wired into CLI pipeline with --above flag"
      contains: "annotate.Annotate"
    - path: "internal/annotate/annotate_test.go"
      provides: "Golden file tests comparing against testdata expected outputs"
      contains: "1_deployment_inline.out"
  key_links:
    - from: "internal/annotate/walker.go"
      to: "internal/managed/fieldsv1.go"
      via: "managed.ParseAssociativeKey for k: prefix"
      pattern: "managed\\.ParseAssociativeKey"
    - from: "cmd/kubectl-fields/main.go"
      to: "internal/annotate/annotate.go"
      via: "annotate.Annotate(root, entries, opts)"
      pattern: "annotate\\.Annotate"
    - from: "internal/annotate/walker.go"
      to: "internal/annotate/walker.go"
      via: "findSequenceItemByValue uses json.Unmarshal for v: content"
      pattern: "json\\.Unmarshal"
---

<objective>
Add list item matching (k: associative keys, v: set values) to the walker, wire annotation into the CLI with --above flag, and validate end-to-end with golden file tests.

Purpose: Completes the annotation engine by handling the remaining FieldsV1 prefix types (k: for list items identified by key, v: for set values) and wires everything into the CLI so the tool produces fully annotated output. Golden file tests validate correctness against the expected output fixtures.

Output: Complete annotation engine with all prefix types handled, CLI wired with --above flag, golden file tests passing against testdata expected outputs.
</objective>

<execution_context>
@/Users/abalkan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abalkan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-annotation-engine/02-RESEARCH.md
@.planning/phases/02-annotation-engine/02-01-SUMMARY.md
@internal/managed/extract.go
@internal/managed/fieldsv1.go
@internal/timeutil/relative.go
@internal/parser/parser.go
@cmd/kubectl-fields/main.go
@testdata/1_deployment.yaml
@testdata/1_deployment_inline.out
@testdata/1_deployment_above.out
</context>

<tasks>

<task type="auto">
  <name>Task 1: List item matching (k: and v: prefixes) in walker</name>
  <files>internal/annotate/walker.go, internal/annotate/walker_test.go, internal/annotate/annotate.go, internal/annotate/annotate_test.go</files>
  <action>
Update `internal/annotate/walker.go` to handle k: and v: prefixes in walkFieldsV1:

1. **k: (associative key) handler:**
   - The yamlNode for k: entries is the SequenceNode (the value of a field like `containers`).
   - Parse the JSON content using `managed.ParseAssociativeKey(content)`.
   - Call `findSequenceItemByKey(yamlNode, assocKey)` to find the matching MappingNode in the sequence.
   - If found and the FieldsV1 value is non-leaf: recurse with `walkFieldsV1(item, nil, val, entry, targets)`. Pass nil for parentKeyNode since sequence items don't have a "key" in the parent mapping sense.
   - If found and the FieldsV1 value is leaf: this is rare but possible. Store target.
   - Inside the recursed walk, a `.` entry means "this sequence item is managed." For k: items with `.`, the target needs special handling:
     - Store with KeyNode=nil, ValueNode=item (the MappingNode).
     - The injection pass will handle this: inline -> HeadComment on `item.Content[0]` (first key of the mapping, producing `- # comment\n  firstKey: val`); above -> HeadComment on item itself.

2. **v: (set value) handler:**
   - The yamlNode is a SequenceNode.
   - Call `findSequenceItemByValue(yamlNode, content)` to find the matching ScalarNode.
   - If found and leaf: store target with KeyNode=nil, ValueNode=item (the scalar).
   - The injection pass: inline -> LineComment on item; above -> HeadComment on item.

3. **findSequenceItemByKey(seq, assocKey) *yaml.Node:**
   - seq must be SequenceNode, iterate Content
   - Each item must be MappingNode; call `matchesAssociativeKey(item, assocKey)`
   - Return first matching item or nil

4. **matchesAssociativeKey(mapping, assocKey) bool:**
   - For each key-value in assocKey map: find the field in mapping using findMappingField, compare values using matchValue
   - All must match for true

5. **matchValue(yamlVal string, jsonVal any) bool:**
   - string: direct comparison
   - float64: compare yamlVal == fmt.Sprintf("%g", v) (handles "80" matching 80.0)
   - bool: compare yamlVal == fmt.Sprintf("%t", v)
   - default: false

6. **findSequenceItemByValue(seq, jsonContent) *yaml.Node:**
   - JSON-decode the content using `json.Unmarshal([]byte(jsonContent), &decoded)`
   - For string values: iterate seq.Content, find ScalarNode where Value == decoded string
   - Return matching node or nil

Update `internal/annotate/annotate.go` injection pass to handle k: item targets:
- When target has KeyNode==nil and ValueNode is a MappingNode (k: item with dot):
  - Inline: set `target.ValueNode.Content[0].HeadComment = comment` (HeadComment on first key produces `- # comment`)
  - Above: set `target.ValueNode.HeadComment = comment` (HeadComment on the MappingNode)
- When target has KeyNode==nil and ValueNode is a ScalarNode (v: match):
  - Inline: set `target.ValueNode.LineComment = comment`
  - Above: set `target.ValueNode.HeadComment = comment`

Add tests to `internal/annotate/walker_test.go`:
- `TestFindSequenceItemByKey_SingleField` - sequence with `[{name: nginx, image: x}, {name: redis, image: y}]`, find by `{"name":"nginx"}` -> returns first item
- `TestFindSequenceItemByKey_MultiField` - find by `{"containerPort":80,"protocol":"TCP"}` in ports sequence
- `TestFindSequenceItemByKey_NotFound` - returns nil when no match
- `TestMatchValue_Types` - string, float64 (80), bool comparisons
- `TestFindSequenceItemByValue_String` - finds `"example.com/foo"` scalar in sequence
- `TestFindSequenceItemByValue_NotFound` - returns nil for missing value
- `TestWalkFieldsV1_AssociativeKey` - YAML sequence `[{name: nginx, image: x}]` with FieldsV1 `{k:{"name":"nginx"}: {f:image: {}}}` -> image value gets target
- `TestWalkFieldsV1_AssociativeKeyDot` - k: item with `.` entry -> item gets dot target
- `TestWalkFieldsV1_SetValue` - YAML sequence `[example.com/foo]` with FieldsV1 `{v:"example.com/foo": {}}` -> scalar gets target

Add tests to `internal/annotate/annotate_test.go`:
- `TestAnnotate_InlineListItemByKey` - containers sequence, k: match with dot + f: fields. Verify: `- # manager` on item, `image: nginx # manager` on field within.
- `TestAnnotate_InlineSetValue` - finalizers sequence, v: match. Verify: `- example.com/foo # manager`.
- `TestAnnotate_AboveListItemByKey` - same but above mode. Verify HeadComment before the `- name: nginx` item.
  </action>
  <verify>
Run `cd /Users/abalkan/oss/kubectl-fields20 && go test ./internal/annotate/ -v` -- all tests pass (both existing from 02-01 and new k:/v: tests). Run `go vet ./internal/annotate/` -- no issues.
  </verify>
  <done>
Walker handles all four FieldsV1 prefix types: f: (field), . (dot), k: (associative key), v: (set value). List items are correctly matched by associative key (single and multi-field) and by scalar value. JSON v: content is properly decoded before comparison. All walker and annotation tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI wiring with --above flag and golden file tests</name>
  <files>cmd/kubectl-fields/main.go, internal/annotate/annotate_test.go</files>
  <action>
**1. Wire annotation into CLI (`cmd/kubectl-fields/main.go`):**

Add `--above` flag to the cobra command:
```go
var aboveMode bool
rootCmd.Flags().BoolVar(&aboveMode, "above", false, "Place annotations on the line above each field instead of inline")
```

Replace the `// TODO(phase2): use entries for field annotation` and `_ = entries` lines with:
```go
if len(entries) > 0 {
    annotate.Annotate(root, entries, annotate.Options{
        Above: aboveMode,
        Now:   time.Now(),
    })
}
```

Add imports for `"time"` and `"github.com/rewanthtammana/kubectl-fields/internal/annotate"`.

The pipeline becomes: parse -> unwrap lists -> for each doc: extract managedFields -> annotate -> strip managedFields -> encode.

IMPORTANT: Annotate BEFORE stripping managedFields. The annotation walker needs the full YAML tree, and managedFields is in metadata which is a sibling, not a parent of annotated fields. Actually, StripManagedFields only removes the managedFields key from metadata -- it doesn't affect the fields being annotated. Order is fine either way, but annotate first is cleaner.

**2. Golden file tests (`internal/annotate/annotate_test.go`):**

Add an integration-style test that processes the full deployment fixture:

- `TestAnnotate_GoldenInline`:
  1. Read `testdata/1_deployment.yaml`
  2. Parse with `parser.ParseDocuments`
  3. For the document's root MappingNode: call `managed.ExtractManagedFields(root)`, then `annotate.Annotate(root, entries, Options{Above: false, Now: fixedNow})`, then `managed.StripManagedFields(root)`
  4. Encode with `parser.EncodeDocuments`
  5. Compare output against `testdata/1_deployment_inline.out`
  6. The `fixedNow` time must produce timestamps matching the expected output. From the inline .out file, the timestamps are "50m ago" for kubectl-client-side-apply (time 2024-04-10T00:44:50Z), "1h ago" for entries at 2024-04-10T00:34:50Z, and "59m21s ago" for finalizerpatcher (time 2024-04-10T00:35:29Z). So fixedNow = time.Date(2024, 4, 10, 1, 34, 50, 0, time.UTC) makes: 00:44:50 -> 50m ago, 00:34:50 -> 1h ago, 00:35:29 -> 59m21s ago. Verify these by computing: 1:34:50 - 0:44:50 = 50m, 1:34:50 - 0:34:50 = 1h, 1:34:50 - 0:35:29 = 59m21s. Correct.

- `TestAnnotate_GoldenAbove`:
  1. Same as inline but with Above=true
  2. Compare against `testdata/1_deployment_above.out`
  3. The above .out uses different timestamps: "16h55m ago" for kubectl-client-side-apply, "17h5m ago" for others, "17h4m ago" for finalizerpatcher. So fixedNow = time.Date(2024, 4, 10, 17, 39, 50, 0, time.UTC) makes: 17:39:50 - 00:44:50 = 16h55m, 17:39:50 - 00:34:50 = 17h5m, 17:39:50 - 00:35:29 = 17h4m21s... but the expected says "17h4m ago" (no seconds). Check: FormatRelativeTime for hours+minutes drops seconds when hours >= 1. Actually looking at the code: it shows hours+minutes but NOT seconds once in the hours range. 17:39:50 - 00:35:29 = 17h4m21s -> FormatRelativeTime returns "17h4m ago" (minutes = totalMinutes - totalHours*60, seconds dropped). So fixedNow = time.Date(2024, 4, 10, 17, 39, 50, 0, time.UTC). Verify: 17:39:50 - 0:44:50 = 16h55m -> "16h55m ago". 17:39:50 - 0:34:50 = 17h5m -> "17h5m ago". 17:39:50 - 0:35:29 = 17h4m21s -> "17h4m ago" (seconds dropped in hours range). Correct.

  NOTE: The golden file comparison may need minor adjustments if go-yaml's comment rendering differs slightly from the expected output files. The expected files appear to be design specs. If there are differences, analyze them carefully:
  - If the difference is in comment placement (wrong node), fix the annotation code
  - If the difference is in whitespace/indentation around comments, update the expected output file to match go-yaml's actual behavior (the tool's output IS the source of truth for formatting)
  - Document any expected output adjustments in the summary

- `TestAnnotate_NoManagedFields` - YAML without managedFields produces no annotations (passthrough). Use `testdata/0_no_managedFields.yaml` if suitable, or create a simple YAML MappingNode.

Run `go test ./internal/annotate/ -v` and `go test ./cmd/kubectl-fields/ -v` (if any CLI tests exist) and `go build ./cmd/kubectl-fields/` to verify everything compiles and works.

Also manually verify: `cat testdata/1_deployment.yaml | go run ./cmd/kubectl-fields/` should produce annotated output (timestamps will differ since Now is real time, but comments should be present on the correct fields).
  </action>
  <verify>
Run `cd /Users/abalkan/oss/kubectl-fields20 && go test ./... -v` -- all tests pass (parser, managed, timeutil, annotate). Run `go vet ./...` -- no issues. Run `go build ./cmd/kubectl-fields/` -- compiles. Run `cat testdata/1_deployment.yaml | go run ./cmd/kubectl-fields/` and verify output has inline annotations on managed fields and no annotations on unmanaged fields. Run `cat testdata/1_deployment.yaml | go run ./cmd/kubectl-fields/ --above` and verify annotations appear above fields.
  </verify>
  <done>
CLI produces annotated YAML output with inline comments (default) or above comments (--above flag). Golden file tests pass against both testdata/1_deployment_inline.out and testdata/1_deployment_above.out with correct timestamps. All prefix types (f:, ., k:, v:) produce correct annotations. Unmanaged fields remain bare. The tool works end-to-end: `kubectl get deploy -o yaml --show-managed-fields | kubectl-fields` produces readable ownership annotations.
  </done>
</task>

</tasks>

<verification>
- `go test ./... -v` passes all tests across all packages
- `go vet ./...` reports no issues
- `go build ./cmd/kubectl-fields/` compiles
- Golden file test for inline mode matches testdata/1_deployment_inline.out
- Golden file test for above mode matches testdata/1_deployment_above.out
- `cat testdata/1_deployment.yaml | go run ./cmd/kubectl-fields/` shows inline annotations
- `cat testdata/1_deployment.yaml | go run ./cmd/kubectl-fields/ --above` shows above annotations
- Fields not in managedFields have no annotations (REQ-013)
- Subresource annotations show (/status) format (REQ-006)
- k: associative key matching works for containers, ports, conditions (REQ associative keys)
- v: set value matching works for finalizers
</verification>

<success_criteria>
- All four FieldsV1 prefix types handled: f:, ., k:, v:
- Inline and above comment modes both work correctly via --above flag
- Golden file tests pass for both modes
- CLI wired end-to-end: stdin YAML -> annotate -> strip managedFields -> stdout
- All tests pass across all packages, clean build
- Phase 2 success criteria from ROADMAP.md all satisfied:
  1. Managed fields have inline comments with manager name and timestamp
  2. --above flag places annotations on line above
  3. Subresource shown in annotation
  4. Unmanaged fields bare
  5. List items matched by associative keys
</success_criteria>

<output>
After completion, create `.planning/phases/02-annotation-engine/02-02-SUMMARY.md`
</output>
